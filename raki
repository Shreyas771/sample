1.a) linear convolution using inbuilt function.


clc;
clear all;
close all;
x1 = [1 4 2]
x2 = [2 3 5]
z = conv(x1,x2)
subplot(2,2,1)
stem(x1)
xlabel('x')
ylabel('y')
title('first input signal)
subplot(2,2,2)
stem(x2)
xlabel('x')
ylabel('y')
title('second input signal')
subplot(2,2,3)
stem(z)
xlabel('x')
ylabel('y')
title('convolution output')



b)using formula method 


clc;
clear all;
close all;
x = input('Enter first sequence =')
h = input('enter the second sequence =')
l1 = length(x)
l2 = length(h)
N = l1+l2-1
x = [x,zeros(1,N-l1)]
h = [h,zeros(1,N-l2)]
for i = 1:N
	y(i)=0
	for j = 1:N
		k = i-j+1
		if k<=0
			k = k + N
		end
	y(i)=y(i)+x(j)*h(k)
	end
end
disp(y)
stem(y)
xlabel('x')
ylabel('y')
title('convolution output')




c)matrix method


clc;
clear all;
close all;
x = input('Enter first sequence =')
h = input('enter the second sequence =')
l1 = length(x)
l2 = length(h)
N = l1+l2-1
x = [x,zeros(1,N-l1)]
h = [h,zeros(1,N-l2)]
x1 = x'
h1 = h'
for n = 1:N-1
	x1 = [x1,circshift(x',n)]
end
y = x1*h'
disp(y)
stem(y)
xlabel('x')
ylabel('y')
title('convolution output')



2.a)  circular convolution using inbuilt function

clc;
clear all;
close all;
x1 = [1 4 2]
x2 = [2 3 5]
l1=length(x1)
l2 = length(x2)
L = max(l1,l2)
z = conv(x1,x2,L)
subplot(2,2,1)
stem(x1)
xlabel('x')
ylabel('y')
title('first input signal)
subplot(2,2,2)
stem(x2)
xlabel('x')
ylabel('y')
title('second input signal')
subplot(2,2,3)
stem(z)
xlabel('x')
ylabel('y')
title('convolution output')


b) formula method 



clc;
clear all;
close all;
x = input('Enter first sequence =')
h = input('enter the second sequence =')
l1 = length(x)
l2 = length(h)
N = max(l1,l2)
x = [x,zeros(1,N-l1)]
h = [h,zeros(1,N-l2)]
for i = 1:N
	y(i)=0
	for j = 1:N
		k = i-j+1
		if k<=0
			k = k + N
		end
	y(i)=y(i)+x(j)*h(k)
	end
end
disp(y)
stem(y)
xlabel('x')
ylabel('y')
title('convolution output')



c) matrix method 


clc;
clear all;
close all;
x = input('Enter first sequence =')
h = input('enter the second sequence =')
l1 = length(x)
l2 = length(h)
N = max(l1,l2)
x = [x,zeros(1,N-l1)]
h = [h,zeros(1,N-l2)]
x1 = x'
h1 = h'
for n = 1:N-1
	x1 = [x1,circshift(x',n)]
end
y = x1*h'
disp(y)
stem(y)
xlabel('x')
ylabel('y')
title('convolution output')


3.a) n-point dft 


clc;
clear all;
close all;
x = input('input sequence')
N = input('N=')
L = length(x)
x = [x,zeros(1,N-L)]
for k = 0:N-1
	for n = 0:N-1
		p = exp((-j*2*pi*k*n)/N)
		w(k+1,n+1) = p
	end
end
y = x*w
disp(y)
h = abs(y)
disp(h)
subplot(1,2,1)
stem(h)
xlabel('x')
ylabel('y')
title('absolute value of y')
h1 = angle(y)
disp(h1)
subplot(1,2,2)
stem(h')
xlabel('x')
ylabel('y')
title('angle of y')





b)n point idft


clc;
clear all;
close all;
x = input('input sequence')
N = input('N=')
L = length(x)
x = [x,zeros(1,N-L)]
for k = 0:N-1
	for n = 0:N-1
		p = exp((j*2*pi*k*n)/N)
		w(k+1,n+1) = p
	end
end
y = (x*w)/N
y1 = round(y)
disp(y1)
xlabel('x')
ylabel('y')
title('IDFT')



4.a)circular convolution using dft and idft


clc;
clear all;
close all;
x = input('Enter first sequence =')
h = input('enter the second sequence =')
N = input('N=')
l1 = length(x)
l2 = length(h)
L = max(l1,l2)
for k = 0:N-1
	for n = 0:N-1
		p = exp((-j*2*pi*k*n)/N)
		w(k+1,n+1) = p
	end
end
X = x*w
H = h*w
Y = X.*H
for k = 0:N-1
	for n = 0:N-1
		p = exp((j*2*pi*k*n)/N)
		w(k+1,n+1) = p
	end
end
y = (Y*w)/N
y1= round(y)
disp(y1)
stem(y1)
xlabel('x')
ylabel('y')
title('circular convolution')


b) linear convolution using dft and idft


clc;
clear all;
close all;
x = input('Enter first sequence =')
h = input('enter the second sequence =')
l1 = length(x)
l2 = length(h)
N = l1+l2-1
x = [x,zeros(1,N-l1)]
h = [h,zeros(1,N-l2)]
for k = 0:N-1
	for n = 0:N-1
		p = exp((-j*2*pi*k*n)/N)
		w(k+1,n+1) = p
	end
end
X = x*w
H = h*w
Y = X.*H
for k = 0:N-1
	for n = 0:N-1
		p = exp((j*2*pi*k*n)/N)
		w(k+1,n+1) = p
	end
end
y = (Y*w)/N
y1 = round(y)
disp(y1)
stem(y1)
xlabel('x')
ylabel('y')
title('linear convolution')




5.a) auto correction by input method

clc;
clear all;
close all;
x = input('input sequence')
L = length(x)
y = xcorr(x)
disp(y)
subplot(1,2,1)
stem(x)
xlabel('x')
ylabel('y')
title('input signal')
subplot(1,2,2)
stem(y)
xlabel('x')
ylabel('y')
title('output signal')


b)energy condition

clc;
clear all;
close all;
x = input('input sequence = ')
l1 = length(x)
y = xcorr(x)
disp(y)
l2 = length(y)
y1 = coil(l2/2)
disp(y1)
x1=sum(x.^2)
y2=y(y1)
if(y2==x1)
	disp('energy condition satisfied')
else 
	disp('energy condition is not satisfied')
end



c) symmetric condition 


clc;
clear all;
close all;
x = input('input sequence')
l1 = length(x)
y = xcorr(x)
disp(y)
l2=length(y)
y1=coil(l2/2)
disp(y1)
for p =0:y1-1
	if(y(y1-1)==y(y1+1))
		disp('y is symmetric')
	else
		disp('y is not symmetric')
	end
end








d)  auto correction using formula method


clc;
clear all;
close all;
x = input('input sequence')
h = flip(x)
l1 = length(x)
l2 = length(h)
N = l1+l2-1
x = [x,zeros(1,N-l1)]
h = [h,zeros(1,N-l2)]
for i = 1:N
	y(i)=0
	for j = 1:N
		k = i-j+1
		if k<=0
			k = k + N
		end
	y(i)=y(i)+x(j)*h(k)
	end
end
disp(y)
stem(y)
xlabel('x')
ylabel('y')
title('output sequence')




e) cross correction 


clc;
clear all;
close all;
x = input('first input sequence = ')
z = input('second input sequence = ')
l1 = length(x)
l2 = length(z)
y = xcorr(x,z)
y1=round(y)
disp(y1)
subplot(2,2,1)
stem(x)
xlabel('x')
ylabel('y')
title('first input signal)
subplot(2,2,2)
stem(z)
xlabel('x')
ylabel('y')
title('second input signal')
subplot(2,2,3)
stem(y1)
xlabel('x')
ylabel('y')
title('output sequence')


